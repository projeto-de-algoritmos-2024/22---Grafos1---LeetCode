function find_p(ps: number[], i: number): number {
    return ps[i] === i ? i : (ps[i] = find_p(ps, ps[i]));
}

function union_p(ps: number[], cs: number[], i: number, j: number): void {
    const pi = find_p(ps, i);
    const pj = find_p(ps, j);
    if (pi !== pj) {
        ps[pi] = pj;
        cs[pj] += cs[pi];
    }
}

function minMalwareSpread(graph: number[][], initial: number[]): number {
    const n = graph.length;
    const ps = new Array(n).fill(0).map((_, idx) => idx);
    const cs = new Array(n).fill(1);

    for (let i = 0; i < n; ++i) {
        for (let j = 0; j < i; ++j) {
            if (graph[i][j]) {
                union_p(ps, cs, i, j);
            }
        }
    }

    const ct = new Array(n).fill(0);
    for (const i of initial) {
        ct[find_p(ps, i)]++;
    }

    let msf_i = Math.min(...initial);
    let msf = 0;
    for (const i of initial) {
        const parent = find_p(ps, i);
        if (ct[parent] !== 1) continue;
        const size = cs[parent];
        if (size > msf) {
            msf = size;
            msf_i = i;
        } else if (size === msf) {
            msf_i = Math.min(msf_i, i);
        }
    }

    return msf_i;
}